<!DOCTYPE html>
<html>

    <head>
        <title> 04 Down the Rabbit Hole - How a simple monitoring task lead me to compiling a custom version of OpenWRT &middot; Viktor Barzin (Viktor Barzin&#39;s Website) </title>

		<meta property='og:title' content="04 Down the Rabbit Hole - How a simple monitoring task lead me to compiling a custom version of OpenWRT"/>
<meta property="og:image" content="/images/04-down-the-rabbit-hole-e955cc2d.png" />
<meta property="og:description" content="In this blogpost I show you my experience of setting up a monitoring service for my website via my OpenWRT router and the ugly hacks I used to make it work." />
<meta property='og:url' content="https://viktorbarzin.me/blog/04-down-the-rabbit-hole/" />
<meta property='og:type' content="website" />
<meta property="og:site_name" content="Viktor Barzin (Viktor Barzin&#39;s Website And Personal Blog)" />
<meta name="description" content="In this blogpost I show you my experience of setting up a monitoring service for my website via my OpenWRT router and the ugly hacks I used to make it work." />

<meta name="twitter:title" content="04 Down the Rabbit Hole - How a simple monitoring task lead me to compiling a custom version of OpenWRT" />
<meta name="twitter:description" content="In this blogpost I show you my experience of setting up a monitoring service for my website via my OpenWRT router and the ugly hacks I used to make it work." />
<meta name="twitter:image" content="/images/04-down-the-rabbit-hole-e955cc2d.png" />
<meta name="twitter:site" content="@viktorbarzin" />
<meta name="twitter:creator" content="@viktorbarzin" />

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://viktorbarzin.me/"
    },
    "articleSection" : "blog",
    "name" : "04 Down the Rabbit Hole - How a simple monitoring task lead me to compiling a custom version of OpenWRT",
    "headline" : "04 Down the Rabbit Hole - How a simple monitoring task lead me to compiling a custom version of OpenWRT",
    "description" : "In this blogpost I show you my experience of setting up a monitoring service for my website via my OpenWRT router and the ugly hacks I used to make it work.",
    "inLanguage" : "en-US",
    "author" : {
        "@type": "Person",
        "name": "Viktor Barzin",
        "image": "",
        "url": "https://viktorbarzin.me/",
        "description": "I've been digging into Programming for quite some time now. My passion for technology has grown into cyber security and automation. I love ot go offline, watch Formula 1, play cheess and go skiing."
    },
    "creator" : "Viktor Barzin",
    "publisher": {
        "@context": "http://schema.org",
        "@type": "Organization",
        "name": "Viktor Barzin",
        "sameAs": [
            "https://www.facebook.com/viktor.barzin",
            "https://github.com/ViktorBarzin",
            "https://twitter.com/ViktorBarzin",
            "https://www.linkedin.com/in/viktor-barzin/"
        ],
        "url": "https://viktorbarzin.me",
        "name": "Viktor Barzin",
        "logo": {
          "@type": "ImageObject",
          "url": "https://viktorbarzin.me/images/profile-picture.jpeg"
        }
    },
    "accountablePerson" : "Viktor Barzin",
    "copyrightHolder" : "Viktor Barzin",
    "copyrightYear" : "8108",
    "datePublished": "2018-10-08 10:04:27 &#43;0100 BST",
    "dateModified" : "2018-10-08 10:04:27 &#43;0100 BST",
    "url" : "https://viktorbarzin.me/blog/04-down-the-rabbit-hole/",
    "wordCount" : "2594",
    "image": 	"/images/04-down-the-rabbit-hole-e955cc2d.png",
    "keywords" : [ "monitor access logs","OpenWrt","iptables","logstash","elk","OSI layers","nginx proxy_pass","log_format","nginx ssl support","recompile OpenWrt","opkg","HAProxy","Temrinating ssl proxy","certificates","luci","Blog" ]
}
</script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>

        <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">





<script src="/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="https://viktorbarzin.me/css/nix.css">


<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">





<script src="/google-analytics.js" type="application/javascript"></script>
<script async src='//www.google-analytics.com/analytics.js'type="application/javascript"></script>


    </head>

    <body>
        <header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=https://viktorbarzin.me/>viktor@web ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="https://viktorbarzin.me/">/home/viktor</a>
				</li>
				
				
				<li class="dropdown">
                    
            		<a href="/blog/">~/blog</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/projects/">~/projects</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/about-me/">~/about-me</a>
            		
        		</li>
        		
			</ul>
		</div>
	</div>
</nav>






</header>

        <div class="container wrapper">
            <h1><a href="https://viktorbarzin.me/blog/04-down-the-rabbit-hole/">04 Down the Rabbit Hole - How a simple monitoring task lead me to compiling a custom version of OpenWRT</a></h1>
            <span class="post-date">Oct 8, 2018 </span>
            <div class="post-content">
                

<h1 id="introduction">Introduction</h1>

<p>In this blogpost I&rsquo;ll go through the journey I went when I was setting up <strong>monitoring</strong> with ELK for <strong>my website</strong>.
The task seemed simple - install *beats and tell it to report to my elk stack vm.
You&rsquo;ll see why in my setup it wasn&rsquo;t as easy as it sounds initially.</p>

<h1 id="the-issue">The issue</h1>

<p>If you recall my <a href="/blog/03-a-walk-down-infrastructure-lane/#the-public-part">network setup</a> had a <em>little</em> issue - <strong>I do not own the public IP address where my infrastructure sits</strong>.
Therefore I&rsquo;ve done some hacks to make it not matter that much.</p>

<p>Well, that technical debt right there brought me some nasty headaches that you&rsquo;re about to find out.</p>

<h1 id="when-apt-install-doesn-t-work">When <code>apt install</code> doesn&rsquo;t work</h1>

<p>So I wanted to setup <strong>monitoring on the access logs</strong> on my website - simple right?</p>

<p><code>tail -f /var/log/nginx/host.access.log</code> should give me everything I need. This is what I wanted:</p>

<p><img src="/images/04-down-the-rabbit-hole-e955cc2d.png" alt="" /></p>

<p>All I had to do is install filebeat on the container and I&rsquo;m done.</p>

<p><img src="/images/04-down-the-rabbit-hole-fd41f4e8.png" alt="" /></p>

<h4 id="any-public-service-i-have-goes-through-the-router-at-home-which-routes-it-via-a-vpn-network-to-reach-its-destination-endpoint">Any public service I have goes through the router at home which routes it via a vpn network to reach its destination endpoint.</h4>

<p>A simple <a href="https://searchnetworking.techtarget.com/definition/Transport-layer">layer 4</a> forwarding on my OpenWRT router looks like this:</p>

<p><img src="/images/04-down-the-rabbit-hole-93481567.png" alt="" /></p>

<p>However, this means that <strong>as far as the webserver is concerned, the client accessing it is my router</strong> since it is <a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT-ting</a> the connection.
This means that regardless of your IP, all I get in the logs is the router&rsquo;s vpn ip:</p>

<p><img src="/images/04-down-the-rabbit-hole-64e92763.png" alt="" /></p>

<p>Well that&rsquo;s an issue since that information is useless for me.</p>

<h1 id="let-s-log-iptables-then">Let&rsquo;s log <em>iptables</em> then!</h1>

<p>If you&rsquo;re not familiar with <a href="https://en.wikipedia.org/wiki/Iptables">iptables</a>, well you <strong>have to</strong> change that!</p>

<p><strong>tl;dr;</strong> is that <em>iptables</em> is a <strong>user-space program</strong> that allows you to <strong>configure the kernel&rsquo;s built-in firewall</strong>.</p>

<p>iptables tries to match connections and take an appropriate action. One of these actions is <code>LOG</code> which writes a line in the kernel&rsquo;s log that looks like this:</p>

<p><code>Mon Oct  8 13:52:12 2018 kern.warn kernel: [512827.190000] IN=br-wan OUT= MAC=12:34:56:78:90:12:34:56:78:90:12:34:56:78 SRC=82.103.122.186 DST=213.191.184.70 LEN=84 TOS=0x00 PREC=0x00 TTL=57 ID=5863 DF PROTO=ICMPTYPE=8 CODE=0 ID=34598 SEQ=1
</code></p>

<p>Cool stuff! - The <em>SRC</em> address is the <strong>public address</strong> I am after. Let&rsquo;s shove this into elk!</p>

<h1 id="logstash-ing-openwrt-s-iptables">Logstash-ing OpenWRT&rsquo;s iptables</h1>

<p><a href="https://www.elastic.co/products/logstash">Logstash</a>, for those of you who haven&rsquo;t heard of it, is part of the becomming more and more famous <a href="https://www.elastic.co/elk-stack">ELK Stack</a>.
(I&rsquo;ll do a blogpost on that at some point)</p>

<p>Logstash is the part that receives logs in any format, parses them to make sense out of them and sends them to <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a> which stores them in a queryable format.</p>

<h2 id="objective-overview">Objective overview</h2>

<p>So what I need to do is the following:</p>

<h4 id="1-create-an-iptables-rule-that-matches-traffic-to-the-website-container-and-log-any-connections-going-there">1. Create an <em>iptables</em> rule that matches traffic to the website container and log any connections going there.</h4>

<h4 id="2-send-the-kernel-logs-over-to-logstash">2. Send the kernel logs over to Logstash.</h4>

<h4 id="3-parse-the-logs-and-send-them-to-elasticsearch">3. Parse the logs and send them to Elasticsearch.</h4>

<h4 id="4-check-result-in-kibana">4. Check result in Kibana</h4>

<h4 id="5-profit">5. Profit!</h4>

<h2 id="let-s-get-started-then">Let&rsquo;s get started then</h2>

<p>So there&rsquo;s a little inconvenience with iptables, namely it <a href="https://askubuntu.com/questions/348439/where-can-i-find-the-iptables-log-file-and-how-can-i-change-its-location#answer-348448">cannot log to an external file</a>, or at least not easily.
Well that&rsquo;s fine, I&rsquo;ll read the logs from the <code>/var/log/kern.log</code> file&hellip;</p>

<p><img src="/images/04-down-the-rabbit-hole-96fb77e8.png" alt="" /></p>

<p>&hellip; if there was one!</p>

<p>It turns out that there are a few a <a href="https://wiki.openwrt.org/doc/howto/log.essentials#logd_and_logread">user-space utilities that are used to read/write to the system log (namely the <em>wtmp</em> file)</a>.</p>

<p>Cool stuff, before sending it to Logstash, let&rsquo;s see what are we actually logging:</p>

<p><img src="/images/04-down-the-rabbit-hole-a8540aeb.png" alt="" /></p>

<p>Right, that&rsquo;s just sending a simple GET request to my website.. .
You can see the entire SSL Handshake occuring and what not&hellip;</p>

<p>But I don&rsquo;t want that - I&rsquo;m interested in something way more simpler - <strong>who</strong> accessed <strong>what</strong> and <strong>when</strong> on my website - I don&rsquo;t give a damn about the SSL handshake&hellip;</p>

<h2 id="back-to-the-drawing-board">Back to the drawing board</h2>

<p>Perhaps I&rsquo;m doing it wrong - <strong>I don&rsquo;t need logging at layer 4 but way higher - at level 7</strong> (If you don&rsquo;t know what I&rsquo;m referring, it&rsquo;s the <a href="https://www.webopedia.com/quick_ref/OSI_Layers.asp">OSI Layers - a must know</a>).</p>

<p><strong>HTTP is a layer 7 protocol and logging it cannot be done by a router which operates at layer 4</strong> - it needs a higher level application to do that.</p>

<h2 id="so-what-can-log-traffic-at-layer-7">So what can log traffic at layer 7?</h2>

<p><a href="https://superuser.com/questions/1266826/openwrt-redirect-incoming-wan-traffic-based-on-domain-name#answer-1266827">Nginx can do that!</a> with the <code>proxy_pass</code> directive!</p>

<p>What&rsquo;s even better - <strong>OpenWRT has a nginx package</strong>! How better can it get?</p>

<p>So before tinkering with my router (which is kinda <strong>critical not to be down</strong> - see my <a href="/blog/03-a-walk-down-infrastructure-lane/#the-public-part">previous post</a>) I decided to install the nginx proxy on another server and test it out.</p>

<p>The host I chose was <code>10.0.20.13</code>. So it basically <strong>runs an nginx instance that proxies connections to the <code>10.2.0.1</code> machine that runs the website</strong>. Here is a picture that illustrates what I want to do:</p>

<p><img src="/images/04-down-the-rabbit-hole-740c9e7f.png" alt="" /></p>

<p>Having this setup, <strong>the goal is to see <code>10.3.2.1</code> in the access logs on <code>10.2.0.1</code></strong>.
Installing nginx and configuring (config file shown later) a server block with the <code>proxy_pass</code> directive yields the following in the logs after <code>curl</code>-ing it:</p>

<p><img src="/images/04-down-the-rabbit-hole-8f780785.png" alt="" /></p>

<p>Well, partial success..</p>

<p>On one hand I still <strong>managed to access the website</strong> which meant that <strong>the proxy was working</strong> correctly but the <strong>web server still logged the proxy&rsquo;s address</strong>.</p>

<p>Luckily, it was a small tweak I had to do in the server settings -
<a href="https://ma.ttias.be/nginx-access-log-log-the-real-users-ip-instead-of-the-proxy/">here is the guide</a> I followed.
Have a read but the <strong>tl;dr;</strong> is that <strong>I needed to change the log format to log the original client&rsquo;s source ip which is passed as a header from the proxy server</strong>.</p>

<p>Add this to the <strong>http {}</strong> section of the nginx conf:</p>

<pre><code>log_format main '$http_x_forwarded_for - $remote_user [$time_local] '
'&quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; '
'&quot;$http_user_agent&quot;'
</code></pre>

<p>Afterwards make use of the specified log format by adding the <code>access_log</code> directive in your server block telling it to use the newly specified <code>log_format</code>:</p>

<pre><code>access_log  /var/www/site/logs/access.log main
</code></pre>

<p><strong>Adding these changes to the config produces the result I&rsquo;m after</strong>:</p>

<p><img src="/images/04-down-the-rabbit-hole-40f93cf5.png" alt="" /></p>

<h2 id="cool-stuff-let-s-smash-it-onto-openwrt-then">Cool stuff! Let&rsquo;s smash it onto OpenWRT then</h2>

<p><a href="https://openwrt.org/packages/start">Installing packages in OpenWRT is rather simple</a> - <strong>there is a package manager</strong> which is quite similar to <code>yum</code> and <code>apt</code> - it&rsquo;s called <code>opkg</code>:</p>

<p><code>opkg update &amp;&amp; opkg install nginx</code></p>

<p>This will get our nginx instance up and running.</p>

<p>The next thing I did was to edit the config file located at <code>/etc/nginx/nginx.conf</code> and add the <code>proxy_pass</code> directive.:</p>

<pre><code>-- snip --
server {
    listen       80;
    server_name  localhost;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        root   html;
        index  index.html index.htm;
        proxy_pass http://10.2.0.1
    }

-- snip --
</code></pre>

<p>Effectively what happens is <strong>everytime a request is made to the <code>/</code> location it is being proxied to <code>http://10.2.0.1</code>.</strong></p>

<p><code>curl</code>-ing the <em>http</em> port <strong>worked fine</strong> and I got the <strong>right client address in the access logs</strong>, however, <strong>my site is running <em>https</em> and all the examples of <code>proxy_pass</code> I saw were using <em>http</em> as backend server</strong>.</p>

<p>Just before getting worried that this won&rsquo;t be possible because of the SSL part I saw the <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/securing-http-traffic-upstream/">nginx documentation on the matter</a> that suggested proxying to <strong><em>https</em></strong> instead of <strong><em>http</em></strong>.
Easy enough right?</p>

<p>Now in order to make this work <strong>I had to terminate the SSL connection at the OpenWRT nginx and setup a new one with the backend server.</strong> To get that going I had to <strong>copy the Let&rsquo;s encrypt certs on the OpenWRT to enable nginx do the SSL termination</strong>.</p>

<p>The documentation link I referred earlier specifies some optimisation options to reduce CPU usage and it all seemed perfect.</p>

<p>Well let&rsquo;s try it out!</p>

<p><img src="/images/04-down-the-rabbit-hole-66e4d436.png" alt="" /></p>

<p>WTF?</p>

<p>Goggling the error yields only <strong>tutorials on how to recompile the nginx package</strong> and I <strong>really didn&rsquo;t want to get into that stuff</strong>&hellip;</p>

<p>A bit more searching finally <a href="https://github.com/openwrt/packages/issues/864#issuecomment-73244902">answers my question</a> on why it doesn&rsquo;t work:</p>

<p><img src="/images/04-down-the-rabbit-hole-b37bd2bc.png" alt="" /></p>

<p><strong>To save some space</strong>, the OpenWRT team (or however maintains the nginx package for OpenWRT) <strong>has decided to not include the SSL module</strong> and I get it - <strong>why the heck would you use your SOHO router as a web proxy that will also encrypt the traffic to the upstream servers?</strong></p>

<h3 id="let-the-recompilation-begin-then">Let the recompilation begin then&hellip;</h3>

<p>I was given no choice - I had to start recompiling stuff if I wanted that to work.
I <strong>reluctantly followed <a href="https://wonpn.com/2018-03-15-compile-nginx-with-ssl.html">this guide</a></strong> to figure out <strong>how to recompile the nginx package so that it includes the SSL module</strong>&hellip;</p>

<p>The guide suggested <strong>downloading the <a href="https://github.com/openwrt/openwrt.git">OpenWRT&rsquo;s source code</a></strong>, using <code>make menuconfig</code> to add <strong>SSL support to the nginx package</strong> and <strong>compiling it</strong>.
The last step was to copy over the nginx binary that would supposedly <em>just work</em>.</p>

<p><strong>It took me like 2 hours or so to finish the compilation process of OpenWRT</strong> and then <strong>another 40 minutes to compile the nginx package with SSL support</strong>&hellip;</p>

<p><a href="https://wiki.openwrt.org/doc/techref/opkg#package_manipulation">opkg&rsquo;s documentation</a> suggested installing <em>.ipk</em> files by running <code>opkg install /path/to/ipk_file.ipk</code>.
This <em>seemed</em> quite handy, unfortunately <strong>when I ran that for some reason it just downloaded the official package from OpenWRT&rsquo;s repositories</strong>.
I tried whatever hacks to make it install the ipk I was giving it but it either refused installing the package or just downloaded the official one&hellip;</p>

<h3 id="well-screw-you-then-opkg">Well screw you then opkg</h3>

<p><a href="https://www.linkedin.com/pulse/manual-extractioninstallation-ipk-packages-openwrt-amit-kumar/">It turned out that ipk files are just normal tar archives</a> that just need to be extracted at the right location.</p>

<p>The steps to manually install an .ipk file are as follows:</p>

<ol>
<li><p>Extract the ipk file somewhere: <code>tar zxpvf /path/to/ipk_file.ipk</code></p>

<p>This extracts 3 files:</p>

<pre><code>./debian-binary
./data.tar.gz
./control.tar.gz
</code></pre></li>

<li><p>data.tar.gz is the one we need. To install it we just need to extract it to <code>/</code>:</p>

<pre><code>cd /
tar zxpvf /path/to/data.tar.gz
</code></pre>

<p>This produces output similar to:</p>

<p><img src="/images/04-down-the-rabbit-hole-fb701c75.png" alt="" /></p></li>
</ol>

<p>It seemed that <strong>all my hopes and dreams would come true</strong> as I saw the <strong>nginx files being extracted to their correct locations</strong>.</p>

<h3 id="the-unfortunate-part">The unfortunate part</h3>

<p>Alas, running <code>/etc/init.d/nginx start</code> <strong>would not start the nginx service</strong> for some reason.
After spending some time debugging I tried running the <strong>nginx binary</strong> itself which just exited with an <strong><code>-ash</code> error that complained that <code>/usr/sbin/nginx</code> file is missing</strong>.
And that&rsquo;s when I&rsquo;m running the file it says it&rsquo;s missing &hellip; obvious error right?</p>

<p><strong>I couldn&rsquo;t figure out why this error occured so I was back to square 1&hellip;</strong></p>

<h3 id="a-new-hope-haproxy">A new hope - HAProxy?</h3>

<p>I got quite frustrated after being so close and eventually failing. Then I decided to <strong>do a bit more reading on what exactly I want to acomplish and the tools that I&rsquo;ll need</strong>.</p>

<p>After reading carefully through all the posts and guides on the nginx SSL issue, <strong>I noticed something I had missed before</strong>:</p>

<p><img src="/images/04-down-the-rabbit-hole-db75dc6c.png" alt="" /></p>

<p>What is this fancy haproxy thing? I&rsquo;ve heard it before and I know it is widely used but <strong>I hadn&rsquo;t had the need to implement it in my infrastructure</strong>&hellip; so far</p>

<p>And <strong>it has SSL support</strong> and that is quite important to me as it turned out.</p>

<h3 id="time-to-haproxy">Time to HAProxy!</h3>

<p><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts">After spending some time getting familiar with this new application</a> it turned out that
<strong>HAProxy&rsquo;s configuration is quite intuitive</strong> - the main parts being <code>frontend</code>, <code>backend</code> and <code>listen</code> block that combines the former 2 for brevity.
I&rsquo;ve found <a href="https://cbonte.github.io/haproxy-dconv/1.7/configuration.html">haproxy options manual</a> really useful. Have a glimpse.</p>

<p>As you&rsquo;d expect the <code>frontend</code> part is what is facing the world and accepts input traffic whereas the <code>backend</code> part is where traffic is being proxied to.</p>

<h4 id="to-terminate-or-not-to-terminate">To terminate or not to terminate?</h4>

<p>Now there is something important you need to know when dealing with proxies and <em>https</em> traffic - the concept of <strong>SSL passthrough and SSL termination</strong>.
<a href="https://serversforhackers.com/c/using-ssl-certificates-with-haproxy">In this blog post both concepts are explained quite well in the context of HAProxy</a>.</p>

<p>Basically, you have to choose whether <strong>you want to terminate the ssl connection at the proxy</strong> and speak http to the backend server <strong>or make the proxy work on a lower level and just pass through tcp packets</strong> without knowing what their content is and <strong>leave the ssl termination for the backend web server</strong>.</p>

<p>Each of these methods has its <strong>pros and cons and there is no <em>better</em> choice</strong> - it all <strong>depends on your needs</strong>.</p>

<p>So I had to take back a step and have a second thought on what would best fit my needs:</p>

<ul>
<li>I want my <strong>backend server to speak https</strong> regardless of whether there is a proxy in front of it or not - this would <strong>allow me to remove the proxy anytime I want without leaving my server serving plain http content</strong>.
<strong>This means</strong> using the proxy in <strong>passthrough mode</strong>, however</li>
<li>I also <strong>need to add a header to the request</strong> to ensure I&rsquo;m <strong>logging the original client&rsquo;s address</strong> and not the proxy&rsquo;s one - <strong>this means ssl termination.</strong></li>
</ul>

<p>As it happens <strong>quite often</strong> - my needs required a <strong>mix from both options.</strong>
After reading a couple of guides on <a href="https://en.wikipedia.org/wiki/TLS_termination_proxy">SSL termination</a> and SSL passthrough I came up with the following HAProxy config:</p>

<pre><code>listen http_proxy
    bind 213.191.184.70:80 # The public IP address of my router
    mode http # We are proxying http here
    option forwardfor # Add X-FORWARDED-FOR header with the client's ip
    option http-server-close # connection: close for the http session
    reqadd X-Forwared-Proto:\ http
    reqadd X-Forwarded-Port:\ 80
    balance roundrobin # If I add other servers it can load balance between them
    server server01 10.2.0.1:80 # My backend server serving the website

listen https_proxy

    bind 213.191.184.70:443 ssl crt /root/le/live/viktorbarzin.me/viktorbarzin.me.pem # the ssl crt part is important - the file contains both the site's cert with the public key

    # We're proxying HTTP here...
    mode http
    option forwardfor
    option http-server-close
    reqadd X-Forwarded-Proto:\ https
    reqadd X-Forwarded-Port:\ 443

    # Simple HTTP round robin over two servers using the specified
    # source ip 192.168.1.1 .
    balance roundrobin
    server server01 10.2.0.1:443 ssl verify none
</code></pre>

<p>It basically forwards both plain <code>http</code> and encrypted <code>https</code> requests to the backend leaving it to decide what to do with them.</p>

<p>When doing the https part, <strong>it terminates the SSL connection and establishes a new one with the backend server</strong>.
On both occasions <strong>it adds <code>X-Forwarded-*</code> headers</strong> to let the nginx server on the other side know it is behind a proxy.</p>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-implement-ssl-termination-with-haproxy-on-ubuntu-14-04">A little quirk in HAProxy</a> is that when binding to a SSL port and specifying that it should listen for <strong>ssl connections</strong>, <strong>the certificate you specify needs to contain both the cert and the public key</strong> (cat the cert and key files into a pem one and let HAProxy use it - it is described in the link above).</p>

<p>The last thing to do is start the HAProxy service and look at the webserver logs:</p>

<p><img src="/images/04-down-the-rabbit-hole-2d9ccfaa.png" alt="" /></p>

<h4 id="success">Success!</h4>

<p>I didn&rsquo;t need to wait for long to find some <strong>dodgy requests coming over all the time</strong>&hellip;</p>

<p><strong>I didn&rsquo;t have time to setup *beats services</strong> to send the logs over to ELK but from this point on <strong>it <em>shouldn&rsquo;t</em> be too difficult</strong> and when I do, I may or may not update this post.</p>

<h1 id="conclusion">Conclusion</h1>

<p><strong>This experience was very satisfying once I got the HAProxy up and running</strong> and most importantly <strong>doing what I needed it to do</strong>.
Messing around with the <em>kilobytes</em> of space that was available on my router was also fun - you don&rsquo;t get deal with <strong>so little amount of physical storage every day</strong>.</p>

<h4 id="p-s-check-as-often-as-possible-that-what-you-are-doing-is-actually-whant-you-need">P.S: Check as often as possible that what you are doing is actually whant you need!</h4>

<p><strong>I can&rsquo;t stress that enough!</strong> I did setup OpenWRT to send it&rsquo;s kernel logs over to Logstash.
If you&rsquo;re curious you do that by going to <code>System &gt; System &gt; Logging</code> in Openwrt and configure your remote server that is going to accept them:</p>

<p><img src="/images/04-down-the-rabbit-hole-3540ed2e.png" alt="" /></p>

<p>I had to figure out how Logstash accepts inputs and what all the configuration files do and in what order.
Then I wrote those awful grok patterns to parse the iptables logs.</p>

<p>I did all this and spent so much time only to find out that <strong>it is logging something I do not need</strong> - namely the tcp conversation rather the http I needed.</p>

<h4 id="so-yeah-small-iterations-to-check-if-you-re-on-the-right-track">So yeah, <strong>small iterations</strong> to check if you&rsquo;re on the right track. ;)</h4>

<p>Till next time.</p>

            </div>
            
            <div class="post-comments">
                <div id="disqus_thread"></div>

<script type="application/javascript">
    var disqus_config = function () {
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "viktorbarzin" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

                
            </div>
            
            <div class="push"></div>
        </div>
        <footer class="footer text-center">
<p>Copyright &copy; 2019 Viktor Barzin
<span class="credit">
	
	
	
	
    
</span>
</p>
</footer>


    </body>
